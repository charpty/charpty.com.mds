> 笔者博客地址：https://charpty.com

我记得面试的时候吧，经常问问别人```hashmap```实现，说着说着就免不了```red-black tree```，红黑树这东西平常都是用现成的，考察别人这个也只是看下是否喜欢专研、有学习劲。

有一次有个同学告诉我他讲不清楚但是可以写一下，很惭愧，一下子让我写一个，伪代码还行，跑起来真不行。

--

## 红黑树理论
红黑树是AVL树的进一步加强，正是二叉平衡查找树有问题才引出了红黑树，和典型数据结构一样，在适当的场景使用红黑树可以很大程度的提高性能。

红黑树首先是一棵二叉查找树，节点的左孩子都比节点小，节点的右孩子都比节点大，与AVL平衡树期望带到的效果一样，都想左右子树的深度相差不要太大，尽量平衡，以便提供平均查找效率。

先记住一下红黑树的以下几个特性，不用急着回忆，后面代码写着写着自然就想起来了。

1. 节点要么是黑色要么是红色，根节点固定为黑色，叶子节点也固定为黑色
2. 子节点和父节点不能同时为红色，子父不连红
3. 从一个节点到其通向到所有叶子节点路径中，所包含的黑色节点数目相同。保证树平衡的关键。

前面两点都很好理解，第2点是用来修改树时判断树是否还为红黑树的主要条件。  
第三点不直观，但是可以这样想，插入或删除一个节点，影响的只是它周边那几个节点（之外的节点本来就是“平衡”的），所以这句话可以翻译成说，要在修改节点后，要把上、左、右这几个位置上的黑色节点数量控制住，所以此时只要把周边几个节点挪一挪，就又恢复平衡了。


对于红黑树的理论讲解，网上非常多，但是我想实在点，一起写吧直接，写本文之前，我也是照着算法伪代码直接开写，很多忘了的都想起来了。

### 插入节点
和业务代码一样，红黑树也无非是增、删、改、查，其它三个都包含着查，增和删对树结构变化最大，我们就看这两个即可理解红黑树了，先来看插入节点的伪代码。


```
// T表示当前红黑树，z表示当前插入的节点
RB-INSERT-FIXUP(T, z)
// ，的父节点为红色
while z->p->color = RED
 	do if z->p = z->p->p->left
 		then y ← z->p->p->right
 			if y->color = RED
 				then z->p->color ← BLACK
 					  y->color ← BLACK
 					  z->p->p->color ← RED
 					  z ← z->p->p
 				else if z = z->p->right
 					then z ← z->p Case 2
 						LEFT-ROTATE(T, z) Case 2
 						z->p->color ← BLACK Case 3
 						z->p->p->color ← RED Case 3
 						RIGHT-ROTATE(T, z->p->p) Case 3
 			else (same as then clause with "right" and "left" exchanged)
 T->root->color ← BLACK
```

## 红黑树实现