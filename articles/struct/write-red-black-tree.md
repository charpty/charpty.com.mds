> 笔者博客地址：https://charpty.com

我记得面试的时候，经常问问别人```hashmap```实现，说着说着就免不了讲讲红黑树，平常都是用现成的，考察别人红黑树也只是看下是否喜欢专研、有学习劲。

有一次有个同学告诉我他讲不清楚但是可以写一下，很惭愧，全忘了，一下子让我写一个，伪代码都够呛了，跑起来更不行。

我给自己想了个简单的记法，父红叔红就变色，父红叔黑靠旋转，祖左父左很简单，删黑带孩最麻烦。

--

## 红黑树
红黑树是AVL树的进一步加强，正是二叉平衡查找树有问题才引出了红黑树，和典型数据结构一样，在适当的场景使用红黑树可以很大程度的提高性能。

红黑树首先是一棵二叉查找树，节点的左孩子都比节点小，节点的右孩子都比节点大，与AVL平衡树期望带到的效果一样，都想左右子树的深度相差不要太大，尽量平衡，以便提供平均查找效率。

先记住一下红黑树的以下几个特性，不用急着回忆，后面代码写着写着自然就想起来了。

1. 节点要么是黑色要么是红色，根节点固定为黑色，叶子节点也固定为黑色（不关键特性3合一）
2. 子节点和父节点不能同时为红色，子父不连红。
3. 从一个节点到其通向到所有叶子节点路径中，所包含的黑色节点数目相同。保证树平衡的关键。

前面两点都很好理解，第2点是用来修改树时判断树是否还是红黑树的主要条件。  
第3点不直观，但是可以这样想，插入或删除一个节点，影响的只是它周边那几个节点（之外的节点本来就是“平衡”的），所以这句话可以翻译成说，要在修改节点后，要把上、左、右这几个位置上的黑色节点数量控制住，所以此时只要把周边几个节点挪一挪，就又恢复平衡了。   
 
所以在红黑树实现中，一般不直接判断第3点（一层层遍历下去效率太低），而仅仅是把周围几个节点通过变色和旋转来达到平衡。


对于红黑树的理论讲解，网上非常多，但是我想实在点，一起写吧直接，写本文之前，我也是照着算法伪代码直接开写，很多忘了的都想起来了。

### 插入节点
和业务代码一样，红黑树也无非是增、删、改、查，其它三个都包含着查，增和删对树结构变化最大，我们就看这两个即可理解红黑树了，先来看插入节点的伪代码（网上找了个，不太对我改了下）。

```
// 在插入节点（二叉查找树的插入）完成后，如果破坏了红黑树特性，则对红黑树进行修复
// T表示当前红黑树，z表示当前插入的节点，->p表示父节点，->right表示右孩子，类推
RB-INSERT-FIXUP(T, z)
// 为了不与“特性3”冲突，所以插入的z是红色，这样黑色节点的数目肯定是不会变化的
// 如果z的父节点为红那就与“特性2：子父节点不同时为红”冲突，此时要分几种情况调整
while z->p->color = RED; do
	 // 如果z的父节点为爷爷节点的左孩子
	if z->p = z->p->p->left then
 			y ← z->p->p->right
 			// 叔叔节点为红色或黑色，分为两种情况处理
 			if y->color = RED then
				// 如果叔叔是红色，爷爷节点是黑色，这种情况比较简单，此时无论父节点是爷爷节点的左还是右节点
				// 都是将父节点设置为黑色，叔叔节点设置为黑色，祖父节点设置为红色
				// 这样一来，子父为红-红的情况自然是不存在了，父节点和叔叔节点由红-红变成了黑-黑
				// 经过这两个节点的到根节点路径黑色节点数没变，都是增加了一个黑色节点
				// 经过爷爷节点到根路径的黑色节点数量则无变化，爷爷节点变成了红色，但是它的两个孩子不论选哪条路都加1了
				z->p->color ← BLACK
				y->color ← BLACK
				z->p->p->color ← RED
				// 爷爷节点设置为红色之后，继续向上判断它和其父节点是否冲突
				z ← z->p->p
 			else 
 				// 如果叔叔节点是黑色就需要旋转树了，如果x为父节点的左孩子，先要额外进行一次进行左旋
 				if z = z->p->right then	
 					z ← z->p
 					LEFT-ROTATE(T, z)
 				// 先假设x为父节点的左节点，这样比较简单，弄清楚了加一层左旋一样的道理
 				z->p->color ← BLACK
 				z->p->p->color ← RED
 				// 上面两行代码已解决了"子父节点不能同为红色"的问题，这样经过爷爷节点走左边的话黑色节点计数还是不变的
                // 但是原本通过爷爷节点走右边的话有两个黑节点的，现在只有一个了，此时只有一个了
                // 关键来了，在节点为红-黑-红-黑（顶上为红）的情况下，右旋使得旋转节点的右孩子路径上黑色节点数加1
 				RIGHT-ROTATE(T, z->p->p)
 	// 如果z的父亲为爷爷节点的右孩子，叔叔节点为红色的逻辑是一样的，只是叔叔为黑时逻辑“相反”
	else (same as then clause with "right" and "left" exchanged)
 T->root->color ← BLACK
```

为了写的更清楚，特地将Java的TreeMap又看了一遍，其中的fixAfterInsertion()函数正是这个逻辑。

到底干了啥呢，其实就当两种情况理解的话，就没那么绕了。只是外面套了一层父节点是爷爷节点的左还是右节点，导致2*2变成4条逻辑线了。 

1. 叔叔节点为红色，太简单了，变个色即可
2. 叔叔节点是红色，那就要进行左右旋了，先理解单纯的各种假设条件下的一次右旋，即可理解其他


#### 情况一：叔叔节点是红色 

![叔叔节点是红色](/struct/rb-tree-uncle-red.png)

这个好理解的，接下来看下叔叔节点是黑色


#### 情况二：叔叔节点是黑色，Z的父节点为爷爷节点的左孩子，Z也为父节点左孩子

![叔叔节点是红色](/struct/rb-tree-uncle-black1.png)

原来的逻辑是先涂色，再右旋，但是不能很好的体现左旋的作用，不管是左旋还是右旋，逻辑都是将红色节点向根节点靠拢，最后将红色节点涂黑。

也就是以下流程

![叔叔节点是红色](/struct/rb-tree-uncle-black2.png)

#### 情况三：叔叔节点是黑色，Z的父节点为爷爷节点的左孩子，Z也为父节点右孩子
此时就比较麻烦了，处理的思想是将情况三转换为情况二，这需要额外的一次左旋。

![叔叔节点是红色](/struct/rb-tree-uncle-black3.png)


### 删除节点
和插入的逻辑类似，插入时是先按照二叉查找树的方式先插入再调整，删除时也是先按照二叉查找树的方式先删除，然后再调整。

二叉查找树的节点删除过程就不细说了，

## 红黑树实现

想了想还是用Python写吧