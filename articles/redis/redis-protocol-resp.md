> 笔者博客地址： https://charpty.com/blog


为了大家看整体源码方便，我将加上了完整注释的代码传到了我的github上供大家直接下载：
> https://github.com/charpty/redis4.0-source-reading

```RESP```全称为```Redis Serialization Protocol```，是Redis的客户端与服务端进行通信的标准协议。客户端只要按照规则发送简单的几行字符串，服务端的响应同样也是简单的几行字符串，```RESP```看名字就是为```Redis```量身定制的，但是官方也建议可以扩展到其它场景使用。 

```RESP```协议的设计思想依旧和```Redis```一样，追求极致的简单，追求快。所以```RESP```协议具备容易理解、容易解析、容易实现的特点。 ```RESP```使得用户可以使用任何流传输协议连接客户端，比如```TCP```、```Unix Socket```、```Linux Pipeline```，也就是说仅仅使用```nc```命令就可以连接```Redis```并进行日常操作。

## 协议通信模型
```Redis```的通信模型很简单：**客户端发送一个指令给服务端，服务端接收指令并响应结果给客户端**。这是非常简洁的通信模型，可以说就是简单的**一问一答**。  

但由于```Redis```的特性，有两点例外  
1. 多问一答：```Redis```支持使用```pipeline```将多个指令一次送给服务器并等待响应  
2. 订阅发布：```Redis```也支持消息订阅-发布模型，这时需要服务端主动给客户端发送消息

## 传输格式
作为一个数据传输协议，```RESP```可以传输以下5种格式的数据   
1. ```Simple Strings```：一行简单字符串如```+OK```，一般为服务器响应OK等字符串  
2. ```Integers```：一个整数，很多命令如```INCR```, ```LLEN```会返回整数  
3. ```Bulk Strings```：其实就是带有前缀参数的字符串，前缀表明了字符串的长度，```L-V```形式，只要读L就知道V的长度  
4. ```Arrays```：这个就是将多种格式打包形成一个数组集合，一次传输多个上述格式的数组  
5. ```Errors```：特殊情况，这是服务端响应的错误信息，一般也为一行字符串如```-WRONGTYPE Operation ...```     

在```RESP```协议中规定，使用第一个字节来区分数据的传输格式，第一个字节的内容代表了后面的数据是何种格式，分别用```'+'```、```':'```、```'$'```、```'*'```、```'-'```来表示上述5种数据传输格式。传输数据都统一使用换行符```"\r\n" (CRLF)```结尾，当然也使用```CRLF```表示另一行。

客户端向```Redis```服务端发送消息时使用的是```Arrays```格式，也就是一个数组集合，数组里元素则都是```Bulk Strings```，也就是```L-V```（字符长度+字符值）形式的字符串。  
```Redis```服务端响应客户端请求时可以发送的格式就多了，以上5种格式都有可能，这根据具体命令的实现而定。

### Simple Strings
```RESP```协议使用第一个字节区分传输格式，而```Simple Strings```的第一个字节是```'+'```，所以```Simple Strings```一定是```'+'```号开头，```CRLF```结尾，中间是内容，并且只有一行，也就是有且只有一个```CRLF```。  
最常见的```"+OK\r\n"```就是经典的```Simple Strings```，只有一行且满足```'+'```号开头，```CRLF```结尾，总共就5个字节。  
每种格式都一样，前面第一个标志符和最后的换行符不表示具体业务含义，对上述的```Simple Strings```来说，中间那```OK```两个字才真的具有意义，客户端也仅需要展示```OK```两字。  


### Integers
```Integers```就是一行普通的数字，以```':'```开头，以```CRLF```结尾，有且只有一行。  
```":123\r\n"```就是一个典型的```Integers```响应。  

在```Redis```中有很多响应是整数形式的命令：返回列表长度的```LLEN```、统计字符串字符个数的```BITCOUNT```、原子自增长命令```INCR```、查询KEY剩余有效时间的```TTL```等命令。

### Bulk Strings
```Bulk Strings```是一种```L-V```形式的字符串，它以```'$'```开头，紧随其后的是一个数字，这个数字表示了实际的字符串数据有多少个字节，再之后则是一个换行```CRLF```以及后续实际的字符串数据。  

```"$5\r\nhello\r\n"```就是一个```Bulk Strings```，第一行数据```$5```表示下一行的实际字符串值的长度为5，也就是下一次```read()```函数只要读6个字节(带结束符)就可以了，读取长度明确之后，少去了很多拆包、粘包判断，极大提高了协议解析效率。 

特殊情况是当想表示一个```NULL```串时的场景，空串```""```可以使用```"$0\r\n\r\n"```表示，但我们知道编程语言都有一个和```C```语言```NULL```类似的表示空的常量，在```Java```中是```null```，在```Python```中是```None```，如何告诉程序端这个命令的返回值是一个```NULL```呢。  
```Redis```使用```"$-1\r\n"```来表示一个```NULL```串，```Redis```官方还特别提醒了```NULL```串和空串的区别。在```hiredis```客户端中，当服务端响应```NULL```串时展示的结果是```nil```，当服务端响应空串时展示的是```""```。

当命令需要返回一个长串字符时一般都使用```Bulk Strings```传输格式，比如```GET```命令。更多的情况是，```Bulk Strings```作为```Arrays```数组中的元素。


### Arrays
其实```Redis```交互格式最多的是```Arrays```数组格式，元素基本上都是```Bulk Strings```。  

```Arrays```格式的开始标志是```'*'```，紧接着是一个数字如```*5\r\n```，表示该数组一共有多少个元素，第一行就结束了。接下来就是实际的元素数据，元素数据可以是```Bulk Strings```或```Integers```格式。  
举个例子：```"*3\r\n:1\r\n:55\r\n$4\r\nlike\r\n"```  
这个数组一共3个元素，这个可以从第一行```*3```中知道，第一个元素是一个整数```1```，整数的标记位是```':'```，第二个元素也是个整数，值为```55```，第三个元素则是一个```Bulk Strings```格式，该大字符串一共有4个字节，可以从第四行的```$4```中知道，真实数据值是```like```。

由上可见，```Arrays```格式也就是多个简单格式的组合，数组中的元素的类型可以各不相同，并且，```Arrays```数组是可以**嵌套**的，如下所示，为了展示清楚，我们每个```CRLF(\r\n)```都换下行。  
```
*3\r\n  
*3\r\n  
:1\r\n  
:55\r\n  
$4\r\n  
like\r\n  
*2\r\n  
+OK\r\n  
-WRONGTYPE\r\n  
:22\r\n  
```

这个数组一共有三个元素，由第一行的```*3```可知，两个元素的类型是数组，一个是整数。第一个数组就是上面举例的那个数组，第二个元素则是一个包含两个简单字符串的数组，最后一个元素则是一个整数```22```。

和空```Bulk Strings```类似，```Arrays```也使用```-1```来表示```NULL```数组，也就是```"*-1\r\n"```，使用```0```表示空数组，也就是```"*0\r\n"```。当然数组里的元素也可以是```NULL```，如```[1,nil,3]```。

**客户端发送请求**  
客户端向```Redis```服务端发送请求时必须使用```Arrays```格式，且元素格式也只能是```Bulk Strings```，服务器响应格式则是根据具体命令实现而定。  
最经典的```GET a```(a已设值)，通过命令```echo '*2\r\n$3\r\nGET\r\n$1\r\na\r\n' | nc 127.0.0.1 6379```可以得到如下结果```$4\r\ntest```。  
类似的```SET a like```的命令格式则是```*3\r\n$3\r\nSET\r\n$1\r\na\r\n$4\r\nlike\r\n```，返回则是```Simple Strings```格式的 ```+OK\r\n```。

**关于Pipelining**  
```Redis```支持客户端一次性发送多个命令给服务端，由服务端一次性执行并一次性返回结果，类似```SET a 1;INCR a;GET a```，返回```OK;2;2```，也就是所谓的流水线```Pipeling```。  
```Pipeling```的实现是嵌套```Arrays```，我想通过签名嵌套数组的描述不难理解。

### Errors
```Redis```专门定义了一种格式用来传递错误信息，这种格式几乎和```Simple Strings```一样，唯一的区别是```Errors```第一个标记字符是```'-'```，而中间的字符串内容就是具体的错误信息。 
 
一般来说错误信息分为两段，第一段是一个单词，比如：```ERR```、```WRONGTYPE```，第一段是对这次错误的整体概述，也可以说是一个错误类型，像是错误编码。```Redis```官方称之为```Error Prefix```。第一段之后紧接着就是一个空格，然后就是第二段。
第二段就是具体的错误信息，帮助客户端理解服务器出错具体原因。

错误发生的情况有很多：  
1. 当你用```GET```命令操作一个```List```时，将返回```-WRONGTYPE Operation against a key holding the wrong kind of value```。  
2. 当你随意输入一个命令```abc```时，将返回```-ERR unknown command 'abc'```。  
3. 当使用```GETBIT```的offset参数输入一个负数时，将返回```-ERR bit offset is not an integer or out of range```

### Inline Commands
内置命令并不是一种标准格式，它更多的是一种解析手段，主要是为了方便没有```Redis```客户端的场景，手里只有```nc```命令或者```telnet```，这个时候让用户手敲一段```*2\r\n$3\r\nGET\r\n$1\r\na\r\n```来实现```GET a```实在有点强人所难。  
所以```Redis```实现了一种所谓内置命令的形式的格式，让用户直接输入```GET a```也依然能够返回结果信息。  
当然不是所有命令都支持以内置命令形式发送并解析，大多数常用且简单的命令，像```SET``、```GET```、```LPUSH```、```PING```等都是支持的。

## 协议实现

```RM_ReplyWithSimpleString```
```shared.ok```





